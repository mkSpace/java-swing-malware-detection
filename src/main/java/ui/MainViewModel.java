package ui;

import data.FileWithStatus;
import data.Malware;
import io.reactivex.Flowable;
import io.reactivex.functions.BiFunction;
import io.reactivex.processors.BehaviorProcessor;
import reactivex.Pair;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

public class MainViewModel {

    private final BehaviorProcessor<List<File>> _files = BehaviorProcessor.createDefault(Collections.emptyList());
    private final Flowable<List<File>> files = _files;
    private final Flowable<Integer> minimumOfThreads = files.map(files -> files.stream().mapToInt(value -> (int) value.length()).sum() / 100 + 1);
    private final BehaviorProcessor<List<File>> _malwareFiles = BehaviorProcessor.createDefault(Collections.emptyList());
    private final Flowable<List<Malware>> malwareFiles = _malwareFiles.map(files -> files.stream().map(file -> new Malware() {
        @Override
        public String getName() {
            return file.getName();
        }

        @Override
        public String getContent() {
            try {
                BufferedReader reader = new BufferedReader(new FileReader(file));
                return reader.readLine();
            } catch (IOException e) {
                e.printStackTrace();
            }
            return "";
        }
    }).collect(Collectors.toList()));
    private final BehaviorProcessor<Integer> _numberOfThreads = BehaviorProcessor.create();

    private final BehaviorProcessor<List<Thread>> _updatedThread = BehaviorProcessor.createDefault(new ArrayList<>());
    private final Flowable<List<Thread>> updatedThread = _updatedThread;
    private final Flowable<List<FileWithStatus>> fileWithStatus = _files.map(fileList ->
            fileList.stream().map(FileWithStatus::new).collect(Collectors.toList())
    ).distinctUntilChanged();
    private final BehaviorProcessor<List<FileWithStatus>> _updatedFiles = BehaviorProcessor.createDefault(new ArrayList<>());
    private final Flowable<List<Thread>> sampleThreadList = _numberOfThreads.zipWith(fileWithStatus, (BiFunction<Integer, List<FileWithStatus>, Pair<Integer, List<FileWithStatus>>>) Pair::new)
            .map(pair -> {
                List<Thread> threadList = new ArrayList<>();
                List<FileWithStatus> files = pair.second;
                List<Malware> malwareList = malwareFiles.blockingFirst();
                for (int i = 0; i < pair.first; i++) {
                    int finalI = i;
                    threadList.add(
                            new Thread(() -> {
                                AtomicInteger readCount = new AtomicInteger(0);
                                List<FileWithStatus> remainedFiles = files.stream().filter(FileWithStatus::canRead).collect(Collectors.toList());
                                FileWithStatus targetFile = remainedFiles.get(finalI % remainedFiles.size());
                                while (readCount.getAndIncrement() < 100 && !remainedFiles.isEmpty()) {
                                    try {
                                        completeFileDetection(targetFile.readAndDetectMalware(malwareList), Thread.currentThread());
                                    } catch (IOException | InterruptedException e) {
                                        e.printStackTrace();
                                    }
                                    remainedFiles = files.stream().filter(FileWithStatus::canRead).collect(Collectors.toList());
                                    if (remainedFiles.size() <= 0) break;
                                    targetFile = remainedFiles.get(finalI % remainedFiles.size());
                                }
                            }, "Thread-" + i)
                    );
                }
                return threadList;
            });
    private final Flowable<List<FileWithStatus>> updatedFiles = _updatedFiles;
    private final Flowable<List<FileWithStatus>> benignFiles = _updatedFiles.map(fileWithStatuses ->
            fileWithStatuses.stream().filter(file -> file.getDetectedMalwareSet().isEmpty()).collect(Collectors.toList())
    ).distinctUntilChanged();
    private final Flowable<List<FileWithStatus>> malwareDetectedFiles = _updatedFiles.map(fileWithStatuses ->
            fileWithStatuses.stream().filter(file -> !file.getDetectedMalwareSet().isEmpty()).collect(Collectors.toList())
    ).distinctUntilChanged();

    public Flowable<List<File>> getFiles() {
        return files;
    }

    public void setFiles(List<File> files) {
        _files.offer(files);
    }

    public Flowable<List<Malware>> getMalwareFiles() {
        return malwareFiles;
    }

    public void setMalwareFiles(List<File> files) {
        _malwareFiles.offer(files);
    }

    public void setNumberOfThreads(int numberOfThreads) {
        _numberOfThreads.offer(numberOfThreads);
    }

    public Flowable<List<FileWithStatus>> getFileWithStatus() {
        return updatedFiles;
    }

    public Flowable<List<FileWithStatus>> getBenignFiles() {
        return benignFiles;
    }

    public Flowable<List<FileWithStatus>> getMalwareDetectedFiles() {
        return malwareDetectedFiles;
    }

    public Flowable<List<Thread>> getUpdatedThread() {
        return updatedThread;
    }

    public Flowable<Integer> getMinimumOfThreads() {
        return minimumOfThreads;
    }

    public void start() {
        List<Thread> threadList = sampleThreadList.blockingFirst();
        threadList.forEach(Thread::start);
    }

    private synchronized void completeFileDetection(FileWithStatus file, Thread thread) throws InterruptedException {
        List<FileWithStatus> copied = _updatedFiles.getValue();
        List<Thread> copiedThreadList = _updatedThread.getValue();
        if (copied == null || copiedThreadList == null) return;
        List<FileWithStatus> currentFiles = new ArrayList<>(copied);
        List<Thread> currentThreads = new ArrayList<>(copiedThreadList);

        if (currentFiles.stream().anyMatch(currentFile -> currentFile.getFile().getName().equals(file.getFile().getName()))) {
            currentFiles.replaceAll(fileWithStatus -> {
                if (fileWithStatus.getFile().getName().equals(file.getFile().getName())) {
                    return file;
                } else {
                    return fileWithStatus;
                }
            });
        } else {
            currentFiles.add(file);
        }
        _updatedFiles.offer(currentFiles.stream().sorted((o1, o2) -> {
            int leftFileNumber = Integer.parseInt(o1.getFile().getName().substring(4, 5));
            int rightFileNumber = Integer.parseInt(o2.getFile().getName().substring(4, 5));
            return Integer.compare(leftFileNumber, rightFileNumber);
        }).collect(Collectors.toList()));

        if (currentThreads.stream().anyMatch(currentThread -> currentThread.getName().equals(thread.getName()))) {
            currentThreads.replaceAll(currentThread -> {
                if (currentThread.getName().equals(thread.getName())) {
                    return thread;
                } else {
                    return currentThread;
                }
            });
        } else {
            currentThreads.add(thread);
        }

        _updatedThread.offer(currentThreads.stream().sorted(Comparator.comparingInt(o -> (int) o.getId())).collect(Collectors.toList()));
    }
}
